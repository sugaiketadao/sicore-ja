# Java コーディング規約

## 概要
- Java のコーディング規約を定義します。
- 本規約に準じることで、プログラムコードの統一化と開発・保守の効率化を目指します。

## 前提条件
- [Webサービス構成標準](../02-develop-standards/11-web-service-structure.md) に従う。
<!-- [バッチ処理構成標準](13-batch-processing-structures.md) に従う。 -->

## 変数名・クラス名
- 変数名はローワーキャメルケースとする。
    - ［例］ `final String lowerCamelCase = map.getString("lower_snake_case")`
- static final 宣言の変数名（定数名）はアッパースネークケースとする。
    - ［例］ `static final String UPPER_SNAKE_CASE = "SNAKE"`
- クラス名はアッパーキャメルケースとする。
    - ［例］ `public class UowerCamelCase {`
- アンダースコア `_` で始まるメソッド名、変数名、定数名は本フレームワークが使用するため、アプリケーションでの使用を禁止する。

## 宣言・スコープ
- 原則として変数には `final` 修飾子を付加して再利用しない。下記のような用途は例外とする。
    - 配列インデックス等のインクリメント。
    - 段階的な文字列の追加や置換え。
    - Beanクラスのメンバー変数。
    - 性能が著しく悪化する場合。
- ローカル変数（メソッド内変数）は使用する直前にスコープができるだけ小さくなる箇所で宣言する。
- 原則としてメンバー変数（メソッド外変数で定数は除く）は使用しない。Beanクラスのメンバー変数は例外とする。
- `static` 修飾子を付加した変数には必ず `final` 修飾子を付加する。
- 機能単位のクラスのメソッドおよび定数は `private`スコープ または `package`スコープ（スコープ無指定）で作成し、他機能から使用しない。本フレームワーク抽象クラスの抽象メソッドは例外とする。
- 機能単位のクラスでクラス継承は行わない。本フレームワーク抽象クラスは例外とする。
- 機能単位の共通部品はユーティリティクラスとして作成する。
- ユーティリティクラスは全てのメソッドおよび定数に `static` 修飾子を付加し、インスタンス化せず使用する。コンストラクタは `private` スコープとする。
- `BigDecimal` のコンストラクタに浮動小数点数リテラルを渡さない。
    - ［NG例］ `new BigDecimal(0.1)`
    - ［OK例］ `new BigDecimal("0.1")`

## アクセス方式
- スーパークラスが持つメソッドやメンバー変数へのアクセスは `super.` を付加する。
- メンバー変数（メソッド外変数で定数は除く）へのアクセスは `this.` を付加する。原則としてメンバー変数は使用しない前提とし、使用箇所（例外箇所）を明示する。

## 比較・評価
- `boolean`変数を `true`／`false` と比較しない。
    - ［NG例］ `if (hasError == true)`
    - ［OK例］ `if (hasError)`
- 変数の値がブランク（`null` を含む）かどうかを判断する際は、本フレームワークの部品を使用する。配列やリスト、マップの中身がゼロ件かどうかを判断する際も同様とする。
    - ［NG例］ `if (val == null || val.trim().length == 0)`
    - ［OK例１］ `if (ValUtil.isBlank(val))`
    - ［OK例２］ `if (ValUtil.isEmpty(ary))`
- 文字列定数と文字列変数が同値かどうかを判断する際は、定数を比較元とする。
    - ［NG例］ `if (value.equals(CONST))`
    - ［OK例］ `if (CONST.equals(value))`
- 文字列変数（定数ではない）同士が同値かどうかを判断する際は、本フレームワークの部品を使用する。
    - ［例］ `if (ValUtil.equals(val1, val2))`

## 処理方式
- リスト型クラスは `java.util.ArrayList` を使用する。
- マップ型クラスは本フレームワークの `com.onepg.util.IoItem` を使用する。`com.onepg.util.IoItem` に格納できない値（クラス）を扱う場合は `java.util.HashMap` を使用する。
- 通常、ループ処理は拡張 `for` 方式を使用する。
    - ［例１］ `for (final String val : list)`
    - ［例２］ `for (final Map.Entry<String, String> ent : map.entrySet()))`
- インデックス値が必要な場合のループ処理は `length` 属性を使用した方式を使用する。
    - ［例］ `for (int i = 0; i < list.length; i++)`
- 文字列を複数回連結する場合は `java.lang.StringBuilder` クラスを使用する。
- `java.lang.AutoCloseable` または `java.io.Closeable` を継承するクラスは `try` 句（try-with-resources文）で宣言する。`close` メソッドの呼び出しは不要とする。
```try句宣言［例］
try (final TxtReader tr = new TxtReader(filePath, ValUtil.UTF8);) {
  for (final String line : tr) {
    ：
  }
}
```
- `System.out` の使用を禁止する。
- 機能単位の処理での `java.lang.Exception` のサブクラス（以下、エラークラスと呼ぶ）のキャッチを禁止する。
- 修正時の差分の可読性を最優先し、三項演算子およびラムダ式 `->`、メソッド参照 `::`、StreamAPI のメソッドチェーンの使用を禁止する。
- 複数個所で同じ意味の同じリテラル値を使用する場合は定数宣言する。１か所のみであればリテラル値でもよい。

## 想定外ケース
- 下記の想定外ケースが発生した場合は `java.lang.RuntimeException` エラーを生成してスローし、処理を中止する。
    - 想定外の引数が渡された場合。
    - 想定外の DB値を取得した場合。
    - 必ず存在するはずの DBデータが存在しない場合。
    - 1件のみ存在するはずの DBデータが複数件存在する場合。
- 機能単位の処理で `java.lang.RuntimeException` 以外のエラークラスは使用しない。
- 想定外の引数や DB値でエラーをスローするロジックは下記のとおりとする。
    - 想定内である `if`, `else if` の `else` 句（`case` 文の `default` 句も同様）。
    - 想定外であることをチェックする `if` 文

```想定外ロジック
［例１］
if (ValUtil.equals(kbn, "1")) {
    // 想定内
} else if (ValUtil.equals(kbn, "2")) {
    // 想定内
} else {
    throw new RuntimeException("想定外の区分です. " + LogUtil.joinKeyVal("区分値", kbn));
}

［例２］
if (!ValUtil.isDate(beforDate)) {
  // 想定外
  throw new RuntimeException("前回日付が不正です. " + LogUtil.joinKeyVal("日付", beforDate));
}
```

- 本フレームワークの `com.onepg.util.SqlUtil` の下記 DBデータ取得メソッドを使い分けることで、想定外ケースでエラーをスローする。
    - `SqlUtil#selectOneExists`：ゼロ件および複数件取得した場合はエラーになる。
    - `SqlUtil#selectOne`：複数件取得した場合はエラーになる。
    - `SqlUtil#updateOne`：更新件数が複数件の場合はエラーになる。
    - `SqlUtil#deleteOne`：削除件数が複数件の場合はエラーになる。
    - `SqlUtil#executeOne`：反映件数が複数件の場合はエラーになる。

## スタイル
- メソッド内や制御構造内（`if`, `for` など）のインデントは、半角スペース 2文字を使用し、タブ文字は使用しない。
- 制御構造（`if`, `for` など）のブレース `{ }` は省略せず、 `{` の直後と `}` の直前に改行する。
- 下記の箇所には半角スペース 1文字を入れる。ただし、行末や行末のセミコロンの直前には入れない。
    - 予約語（`if`, `return` など）とその後ろにある文字列の間。
    - 予約語（`else`, `catch` など）とその前にある文字列の間。
    - 開始ブレース `{` とその前にある文字列の間。
    - 全ての演算子（`+`, `=`, `!==`, `&&` など）の前後。ただし、インクリメント演算子とデクリメント演算子は除く。
    - カンマ、コロン、セミコロンとその後ろにある文字列の間。
- 1行はインデントを除いた桁数で 100 桁を目安とし、それ以上になる場合は折り返す。それ以下であれば不要な折り返しは行わない。

## コメント
- ロジックはコメントアウトせず、削除する。注意点がある場合は、注意点のみコメントとして残す。
- 変更履歴のコメントは記載しない。注意点がある場合は、注意点のみコメントとして残す。
- メソッド内の変数を除き、全ての宣言部に JavaDoc を記載する。メソッド内の変数に説明が不要というわけではなく、通常コメントとして説明を記載する。
- `private` スコープ宣言のメソッドや変数、定数の説明は簡略化してもよい。
- JavaDoc のコメントは `/** */` で囲む。
- 通常コメント（JavaDoc用以外）は行頭に `//` を付加する形式で 1行使用して記述する。行末でのコメントは禁止する。

## JavaDoc
- 機能単位のパッケージごとに `package-info.java` を作成して機能名を記載する。
- メソッド宣言部のフォーマットは下記のとおりとする。
    - 最初の行にクラス名称やメソッド名称を記載する。名前の後ろに `.<br>` を付加する。
    - クラス名称やメソッド名称はその役割や責務を簡潔に一言で表したものとし、英字のクラス名・メソッド名そのものは記載しない。
    - 2行目以降にその役割や責務、処理の説明を `<ul>` または `<ol>` を使って箇条書きで記述する。
    - メソッドの引数には `@param`タグで説明を記述する。
        - `@param`タグは 「@param 変数名 説明」 の形式で記述する。
    - メソッドの戻値には `@return`タグで説明を記述する。
        - `@return`タグは 「@return 説明」 の形式で記述する。
        - 戻値として `null` が返される可能性がある場合は「説明」の最後に "（null有り）" と記述する。
- 抽象メソッドの実装部分には `{@inheritDoc}` を付加する。`{@inheritDoc}` のみの JavaDoc でもよい。
``` 抽象メソッド実装部分JavaDoc例
  /**
   * {@inheritDoc}
   */
  @Override
```
- 他Javaクラスや他Javaメソッドの JavaDoc を参照する場合は `@see`タグで記述する。
- 文中のサンプルコーディングは `<pre><code>` で囲んで記述する。1行の短いコードであれば `<code>` だけで囲む。
- 以下の名前についても `<code>` で囲んで記述する。
    - DBテーブル名
    - 項目名
    - Javaクラス名
    - Javaメソッド名
- 他JavaクラスのJavaメソッド名は `<code>Javaクラス名#メソッド名</code>` の形式で記述する。
- DBテーブル名と項目名を繋げて記載する場合は `<code>DBテーブル名.項目名</code>` の形式で記述する。
