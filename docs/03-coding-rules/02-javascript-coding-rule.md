# JavaScript コーディング規約

## 概要
- JavaScript のコーディング規約を定義します。
- 本規約に準じることで、プログラムコードの統一化と開発・保守の効率化を目指します。

## 前提条件
- [Webページ構成標準](../02-develop-standards/01-web-page-structure.md) に従う。

## 変数名・メソッド名・クラス名
- 変数名はローワーキャメルケースとする。
    - ［例］ `const lowerCamelCase = req['lower_snake_case']`
- const 宣言かつ初期値がリテラルの変数名（＝定数名）はアッパースネークケースとする。
    - ［例］ `const UPPER_SNAKE_CASE = 'SNAKE'`
- 連想配列のキーはローワースネークケースとする。
    - ［例］ `const obj = {lower_snake_case: 'snake'}`
- メソッド名はローワーキャメルケースとする。
    - ［例１］ `const init = async function`
    - ［例２］ `const editMove = async function`
- クラス名はアッパーキャメルケースとする。
    - ［例１］ `const UowerCamelCase = /** @lends UowerCamelCase */ {`
    - ［例２］ `class UowerCamelCase {`
- `remove` 単体をメソッド名や変数名として使用しない。
    - ［NG例］ `const remove = function`
    - ［OK例］ `const removeLine = function`
- アンダースコア `_` で始まるメソッド名、変数名、定数名、連想配列（リクエストやレスポンスを含む）のキーは本フレームワークが使用するため、アプリケーションでの使用を禁止する。

## 宣言
- 原則として変数は `const` で宣言し、再利用しない。下記のような用途は例外として `let` で宣言する。`var` 宣言は使用しない。
    - 配列インデックス等のインクリメント。
    - 段階的な文字列の追加や置換え。
    - 段階的な配列の追加。
    - 性能が著しく悪化する場合。
- ローカル変数（メソッド内変数）は使用する直前にスコープができるだけ小さくなる箇所で宣言する。
- メンバー変数（メソッド外変数で定数は除く）は使用しない。
- 機能単位のクラスでクラス継承は行わない。
- 機能単位の共通部品はユーティリティクラスとして作成する。
- ユーティリティクラスはインスタンス化せず使用する。
- 配列および連想配列はリテラルで記述する。
    - ［NG例１］ `const ary = new Array()`
    - ［NG例２］ `const obj = new Object()`
    - ［OK例１］ `const ary = []`
    - ［OK例２］ `const obj = {}`
- 連想配列のキーはシングルクォーテーションで囲まない。
    - ［NG例］ `const obj = {'key1': 'V1', 'key2': 2}`
    - ［OK例］ `const obj = {key1: 'V1', key2: 2}`

## アクセス方式
- 連想配列のキーアクセスはブラケット記法で記述する。
    - ［NG例］ `const val = obj.user_id`（ドット記法）
    - ［OK例］ `const val = obj['user_id']`

## 比較・評価
- 等価演算子は `==`, `!=` ではなく、`===`, `!==` を使用する。
- `boolean`変数を `true`／`false` と比較しない。
    - ［NG例］ `if (hasError === true)`
    - ［OK例］ `if (hasError)`
- 変数の値がブランク（`null` を含む）または変数自体が `undefined` かどうかを判断する際は、変数のみで判断せず、本フレームワークの部品を使用する。配列や連想配列の中身がゼロ件かどうかを判断する際も同様とする。
    - ［NG例］ `if (!val)`
    - ［OK例１］ `if (ValUtil.isBlank(val))`
    - ［OK例２］ `if (ValUtil.isEmpty(ary))`

## 処理方式
- 機能単位の処理ではクラスを作成せず、1処理1メソッドとする。
- 配列のループ処理は `of` を使用した方式を使用する。
    - ［例］ `for (const val of ary)`
- 連想配列のループ処理は `in` を使用した方式を使用する。
    - ［例］ `for (const key in obj)`
- 修正時の差分の可読性を最優先し、三項演算子およびアロー関数 `=>` の使用を禁止する。

## エラー処理
- 機能単位の処理ではエラーはキャッチしない。

## ログ出力
- 機能単位の処理ではコンソールログを出力しない。開発時に一時的に出力したとしても、テスト完了までに削除する。

## スタイル
- メソッド内や制御構造内（`if`, `for` など）のインデントは、半角スペース 2文字を使用し、タブ文字は使用しない。
- 制御構造（`if`, `for` など）のブレース `{ }` は省略せず、 `{` の直後と `}` の直前に改行する。
- 文字列はシングルクォーテーションで囲む。
- 変数を文字列連結する場合は、テンプレートリテラルを積極的に使用する。
- 長い文字列リテラルを改行する場合は、行末に `\` を付加する方式は使用せず、テンプレートリテラルを使用する。
- 下記の箇所には半角スペース 1文字を入れる。ただし、行末や行末のセミコロンの直前には入れない。
    - 予約語（`if`, `return` など）とその後ろにある文字列の間。
    - 予約語（`else`, `catch` など）とその前にある文字列の間。
    - 開始ブレース `{` とその前にある文字列の間。
    - 全ての演算子（`+`, `=`, `!==`, `&&` など）の前後。ただし、インクリメント演算子とデクリメント演算子は除く。
    - カンマ、コロン、セミコロンとその後ろにある文字列の間。
- 1行はインデントを除いた桁数で 100 桁を目安とし、それ以上になる場合は折り返す。それ以下であれば不要な折り返しは行わない。

## コメント
- ロジックはコメントアウトせず、削除する。注意点がある場合は、注意点のみコメントとして残す。
- 変更履歴のコメントは記載しない。注意点がある場合は、注意点のみコメントとして残す。
- メソッド内の変数を除き、全ての宣言部に JSDoc を記載する。メソッド内の変数に説明が不要というわけではなく、通常コメントとして説明を記載する。
- private スコープ宣言のメソッドや変数、定数の説明は簡略化してもよい。
- JSDoc のコメントは `/** */` で囲む。
- 通常コメント（JSDoc用以外）は行頭に `//` を付加する形式で 1行使用して記述する。行末でのコメントは禁止する。
- 体言止めで記載しないことで統一する。

## JSDoc
- メソッド宣言部のフォーマットは下記のとおりとする。
    - 最初の行にクラス名称やメソッド名称を記載する。名前の後ろに `.<br>` を付加する。
    - クラス名称やメソッド名称はその役割や責務を簡潔に一言で表したものとし、英字のクラス名・メソッド名そのものは記載しない。
    - 2行目以降にその役割や責務、処理の説明を `<ul>` または `<ol>` を使って箇条書きで記述する。
    - サンプルのコーディングは `<pre><code>` で囲む。`<code>` 内での HTMLタグはエスケープ文字で記述する。
    - メソッドの引数には `@param`タグで説明を記述する。
        - `@param`タグは 「@param {型} 変数名 説明」 の形式で記述する。
        - 省略可能な引数の「変数名」は `[]` で囲み、「説明」の最後に "（省略可能）" と記述する。
        - 「{型}」は ［例］ `{string}`、`{Object}`、`{Array<string>}` などで記述する。
    - メソッドの戻値には `@returns`タグで説明を記述する。
        - `@returns`タグは 「@returns {型} 説明」 の形式で記述する。
        - 「{型}」は ［例］ `{string}`、`{Object}`、`{Array<string>}` などで記述する。
        - 戻値として `null` が返される可能性がある場合は「{型}」に ［例］ `{Object|null}` と記述する。
- private スコープのメソッドや変数、定数には `@private`タグを付与する。
